package willey.lib.physics.polymer.lattice;

import java.util.Iterator;

import junit.framework.Assert;

import org.junit.Test;

import willey.lib.math.MathUtil;
import willey.lib.math.linearalgebra.CartesianVector;
import willey.lib.test.AbstractTest;
import willey.lib.util.Function;
import static willey.lib.math.linearalgebra.CartesianVector.*;

public class LatticeTest extends AbstractTest
{
	@Test
	public void testMovements()
	{
		int vCount = 0;
		Iterator<Function<CartesianVector, CartesianVector>> vIterator = new Lattice(
				4).getNewLatticeCoordinatesFunctions().iterator();
		while (vIterator.hasNext())
		{
			vIterator.next();
			vCount++;
		}
		Assert.assertEquals(27, vCount);
	}

	@Test
	public void getLatticeCoordinates()
	{
		Lattice vLattice = new Lattice(4);
		CartesianVector vVector = vector(4.1, 3.2, -1.7);
		Assert.assertTrue(vLattice.getLatticeCoordinates(vVector)
				.coordinatesEqual(vector(0.1, 3.2, 2.3)));

		int vDimension = 8;
		vLattice = new Lattice(vDimension);
		for (int i = 0; i < 1000000; i++)
		{
			vVector = vLattice.getLatticeCoordinates(randomUnitVector().scale(
					MathUtil.kRng.nextInt()));
			Assert.assertTrue(vVector.x() < vDimension && vVector.x() >= 0);
			Assert.assertTrue(vVector.y() < vDimension && vVector.y() >= 0);
			Assert.assertTrue(vVector.z() < vDimension && vVector.z() >= 0);
		}
	}

	@Test
	public void testInNewLattice()
	{
		Lattice vLattice = new Lattice(4);
		CartesianVector vVector = vector(2.1, 3.2, -1.7);
		Assert.assertTrue(vLattice.getInNewLattice(vVector, new NoMove())
				.coordinatesEqual(vector(2.1, 3.2, 2.3)));
		Assert.assertTrue(vLattice.getInNewLattice(vVector, new SubtractX(4))
				.coordinatesEqual(vector(-1.9, 3.2, 2.3)));

		int vDimension = 8;
		vLattice = new Lattice(vDimension);
		for (int i = 0; i < 1000000; i++)
		{
			vVector = vLattice.getInNewLattice(
					randomUnitVector().scale(MathUtil.kRng.nextInt()),
					new SubXYAddZ(vDimension));
			Assert.assertTrue(vVector.x() < 0 && vVector.x() >= -vDimension);
			Assert.assertTrue(vVector.y() < 0 && vVector.y() >= -vDimension);
			Assert.assertTrue(vVector.z() < vDimension * 2
					&& vVector.z() >= vDimension);
		}
	}

	private static class NoMove implements Function<LatticeCube, LatticeCube>
	{
		@Override
		public LatticeCube apply(LatticeCube pFrom)
		{
			return pFrom;
		}
	}

	private static class SubXYAddZ implements
			Function<LatticeCube, LatticeCube>
	{
		private final int mDimension;

		private SubXYAddZ(int pDimension)
		{
			mDimension = pDimension;
		}

		@Override
		public LatticeCube apply(LatticeCube pFrom)
		{
			return pFrom.addX(-mDimension).addY(-mDimension).addZ(mDimension);
		}
	}

	private static class SubtractX implements
			Function<LatticeCube, LatticeCube>
	{
		private final int mDimension;

		private SubtractX(int pDimension)
		{
			mDimension = -pDimension;
		}

		@Override
		public LatticeCube apply(LatticeCube pFrom)
		{
			return pFrom.addX(mDimension);
		}
	}
}
